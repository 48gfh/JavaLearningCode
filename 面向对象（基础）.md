## 面向对象与面向过程
面向对象：对独立的功能进行打包。做成一个小的模块。在使用过程中需要那个功能就调用对应模块以实现。可以理解成积木组装。面向对象偏重于**用谁去实现**
面向过程：注重事件的具体过程/步骤，以函数为最小单位。面向过程偏重于**怎么去实现**
## 类和对象
> - 类：是一种**模板（一类东西长什么样、能干什么）**，描述一类具有相同属性（字段）和行为（方法）的事物
> 	- 类定义了对象的**结构**和**行为**
> 	- 类本身不占用内存，相当于一个设计模板
> 	- 类是抽象的并不能直接使用，必须通过它创建对象
> - 对象：是**类的具体实现（根据模板造出来的你具体东西）**
> 	- 对象是依据类创建出来的
> 	- 每个对象都有自己独立的属性值
> 	- 对象中可以调用类中定义的方法
> **总结：类是对象的抽象，对象是类的案列；*编程时请务必先设计类，在创建对象，通过对象完成实际任务* **
### 类的实现
编写类的规范：
> - 类的命名见名知意，按驼峰命名法
> - 编写类的特性，也就是类中定义的变量，称为成员变量/类的属性
> - 编写类的行为，也就是类中定义的方法，称为类的成员方法/类的方法
> - 一个代码文件中，可以写多个class类，但是智能有一个用`public`修饰，且`public`修饰的类名必须是代码的文件名

属性(成员变量)定义格式：
```Java
/**
注：成员（属性变量）用于定义该类型或该类型对象包含的数据或者静态特征；属性作用范围是整个类体。
*/
[修饰符] 属性类型  属性名 = [默认值];
```


方法(成员方法)定义格式：
```Java
/*
注：方法用于定义该类或该类实列的行为特征和功能实现。方法与面向过程里的函数相似。面向过程中，函数是基本单位，整个程序是由一个个函数调用组成。面向对象中，整个程序的基本单位是类。方法是从属于类和对象的。
*/
[修饰符]  方法返回值类型  方法名(形参){
方法体
return 方法返回值;
}
```

以创建一个学生类（代码示例）：
```Java
public class Student {
    // 属性（字段）—— 描述“是什么”
    String name;
    int age;

    // 行为（方法）—— 描述“能做什么”
    void study() {
        System.out.println(name + " 正在学习。");
    }

    void introduce() {
        System.out.println("我叫 " + name + "，今年 " + age + " 岁。");
    }
}
```
> - 这个 `Student` 类定义了“学生”应该有哪些信息（名字、年龄）和能做什么（学习、自我介绍），但它本身不是具体的学生

### 对象的实现
对象创建格式：
```
类名 对象名 = new 类名();
对象名.属性名 = 值;
[返回值类型  名字] = 对象名.方法名(实参);
```

创建学生类对象（代码示例）：
```Java
public class Main {
    public static void main(String[] args) {
       // 使用 new 关键字创建对象
        Student student1 = new Student();
        student1.name = "张三";
        student1.age = 20;

        Student student2 = new Student();
        student2.name = "李四";
        student2.age = 22;

        // 调用对象的方法
        student1.introduce();  // 输出：我叫 张三，今年 20 岁。
        student2.study();      // 输出：李四 正在学习。
    }
}
```
> - 这里 `student1` 和 `student2` 就是两个**对象**，它们都来自 `Student` 这个类，但各自拥有不同的数据。

## 局部变量与成员变量

成员变量：
 > - 定义位置：类的内部
 > - 生命周期：随着对象的创建而存在，随着对象的销毁而消失
 > - 内存位置：堆内存

局部变量：
> - 定义位置：方法内部或代码块内部
> - 生命周期：随着方法的调用而存在，随着方法的结束而消失
> - 内存位置：栈内存


## 构造器
构造器是一种特殊的方法。在调用构造器的时候，如果编写的类中没有写构造器，那么系统会默认给你分配一个构造器，只是我们看不到（Java会默认提供一个无参构造器；一旦定义了有参构造器，默认无参构造器就不再提供）。类在设计时，如果不写构造器，java会自动生成一个无参构造器。
### 构造器的定义
构造器的格式：
```Java
[修饰符] 类名(参数列表) { 
	//方法体
}

// 构造方法名必须与类名完全相同

```

构造器和方法的区别：
> - 构造器中无返回值类型，连`void`也不行
> - 构造器内部不能有return + 返回值语句
> - 构造器名字必须和类名一样

构造器作用
> - 在调用对象时，完成对对象成员变量/属性的初始化

构造器的分类：
> - 空参数构造器 ：构造方法没有参数（系统会自动分配）
> - 带参数构造器 ：构造方法有参数，参数个数按照实际需求去定义即可。

学生构造器（代码示例）：

```java
public class Student {
    String name;
    int age;

    // 无参构造器
    public Student() {
        System.out.println("调用了无参构造器");
        name = "未知";
        age = 0;
    }

    // 有参构造器
    public Student(String name, int age) {
        System.out.println("调用了有参构造器");
        this.name = name;
        this.age = age;
    }

    void introduce() {
        System.out.println("我叫 " + name + "，今年 " + age + " 岁。");
    }
}

// 测试
public class Main {
    public static void main(String[] args) {
        Student s1 = new Student();               // 调用无参构造器
        Student s2 = new Student("张三", 20);     // 调用有参构造器

        s1.introduce(); // 输出：我叫 未知，今年 0 岁。
        s2.introduce(); // 输出：我叫 张三，今年 20 岁。
    }
}
```



### 构造器的重载

定义：
> - 在**同一个类中定义多个构造器**，它们的**参数列表不同**（参数个数、类型或顺序不同），这就是构造器的重载。

构造器重载的好处：
>  - 提供多种创建对象的方式。
 > - 提高代码灵活性和可读性。


学生构造器（重载）
```Java
public class Person {
    String name;
    int age;
    String address;

    // 1. 无参构造器
    public Person() {
        this("匿名", 0, "未知"); // 调用本类其他构造器（推荐写法）
    }

    // 2. 只有名字
    public Person(String name) {
        this(name, 0, "未知");
    }

    // 3. 名字 + 年龄
    public Person(String name, int age) {
        this(name, age, "未知");
    }

    // 4. 全参数构造器（主构造器）
    public Person(String name, int age, String address) {
        this.name = name;
        this.age = age;
        this.address = address;
    }

    void info() {
        System.out.println(name + ", " + age + "岁, 住在" + address);
    }
}

// 测试
public class Main {
    public static void main(String[] args) {
        Person p1 = new Person();
        Person p2 = new Person("李四");
        Person p3 = new Person("王五", 25);
        Person p4 = new Person("赵六", 30, "北京");

        p1.info(); // 匿名, 0岁, 住在未知
        p2.info(); // 李四, 0岁, 住在未知
        p3.info(); // 王五, 25岁, 住在未知
        p4.info(); // 赵六, 30岁, 住在北京
    }
}
```

==还需要注意的是==：
> - 写代码时一定要保证空构造器的存在
> - 在重载构造器以后，一旦定义了有参数构造器，Java就不会帮我们的类自动生成无参构造器，此时建议写一个无参构造器。
> - 在表示对象的属性前加上`.this`来修饰，因为`this`代表的就是你创建的那个对象。


## 内存分析
### 内存分析图一
```java
 public class Person {
    int  id;
    int  age;

    public static void main(String args[]){
            Person p = new Person();
    }
}
```
![[Pasted image 20251021181250.png]]
栈：方法运行时所进入的内存(局部变量) 
堆：new出来的对象(成员变量) 
方法区：加载的字节码信息
### 内存分析图二
```java
public class Person {
    int id;
    int age;
    String school;
    public Person (int a,int b,String c){
        id = a;
        age = b;
        school = c;
    }
    public static void main(String args[]){
        Person p = new Person(1,20, "海淀");
    }
}

```
![[Pasted image 20251021181338.png]]
栈：方法运行时所进入的内存(局部变量) 
堆：new出来的对象(成员变量) 
字符串常量池：字符串（唯一） 
方法区：加载的字节码信息
### 内存分析图三
```java
public class Person {
    int id;
    int age;
    Person (int a,int b){
        id=a;
        age=b;
    }
}

class Test{
    public void change(Person p){
        p.id = 2;
        p.age = 18;
    }
    public static void main(String[] args) {
        Person p = new Person(1,20);
        Test t = new Test();
        t.change(p);
        System.out.println(p.id);
        System.out.println(p.age);
    }
}

```

![[Pasted image 20251021181417.png]]
多个变量指向同一个对象会互相影响
## `this`关键字
### `this`的基本概念
`this`是`Java`中的一个关键字。==是当前引用对象的指针，指向当前对象自身。==我们可以理解为"这个对象的自己"
代码示例：
```Java
public class Person {
    private String name;
    private int age;
    
    // 使用this来引用当前对象的成员变量
    public void setName(String name) {
        this.name = name;  // this.name指成员变量，name指参数
    }
}
```

### 使用`this` 区分成员变量和局部变量
当属性名字和形参发生重名的时候，或者属性名字和局部变量发生重名的时候，就会发生就近原则。所以需要用`this`来指定属性（成员变量）。若不发生重命名的话，可以省略`this`。
使用格式：`this.修饰`
```Java
public class Student {
    private String name;    // 成员变量
    private int age;        // 成员变量
    
    public void setInfo(String name, int age) {
        // 使用this区分同名变量
        this.name = name;   // this.name是成员变量，name是参数
        this.age = age;     // this.age是成员变量，age是参数
    }
    
    public void printInfo() {
        String name = "临时名字";  // 局部变量
        System.out.println("局部变量name: " + name);
        System.out.println("成员变量name: " + this.name);
    }
}
```


### `this`调用方法
在同一个类中可以通过`this`实现不同方法之间的互相调用。 这种调用可以使代码更加清晰，方法之间的组合更加灵活。
代码示例：
```Java
//方法之间调用
public class Calculator {
    private int result;
    
    // 基础加法方法
    public void add(int a, int b) {
        this.result = a + b;
        this.displayResult();  // 调用另一个方法
    }
    
    // 复杂计算方法
    public void complexCalculation(int a, int b, int c) {
        // 调用其他方法来组合功能
        this.add(a, b);
        this.multiply(c);
        this.displayResult();
    }
    
    // 乘法方法
    public void multiply(int factor) {
        this.result *= factor;
    }
    
    // 显示结果方法
    public void displayResult() {
        System.out.println("当前结果: " + this.result);
    }
    
    // 重置方法
    public void reset() {
        this.result = 0;
        this.displayResult();  // 调用显示方法
    }
}

//构造器调用普通方法
public class Student {
    private String name;
    private int score;
    private String grade;
    
    // 构造器
    public Student(String name, int score) {
        this.name = name;
        this.score = score;
        this.calculateGrade();  // 构造器中调用方法
    }
    
    // 计算等级的方法
    private void calculateGrade() {
        if (this.score >= 90) {
            this.grade = "A";
        } else if (this.score >= 80) {
            this.grade = "B";
        } else if (this.score >= 70) {
            this.grade = "C";
        } else {
            this.grade = "D";
        }
    }
    
    // 更新分数的方法
    public void updateScore(int newScore) {
        this.score = newScore;
        this.calculateGrade();  // 调用方法重新计算等级
    }
    
    public void displayInfo() {
        System.out.println("学生: " + this.name + ", 分数: " + this.score + ", 等级: " + this.grade);
    }
}

```


### `this` 调用构造器
同一个类中的构造器可以通过`this`实现在一个构造器中调用另一个构造器。但是==***`this()` 必须放在构造器的第一行***==
```Java
public class Car {
    private String brand;
    private String color;
    private double price;
    
    // 无参构造器
    public Car() {
        this("未知品牌", "黑色", 0.0);  // 调用三参数构造器
    }
    
    // 单参数构造器
    public Car(String brand) {
        this(brand, "白色", 100000.0);  // 调用三参数构造器
    }
    
    // 三参数构造器
    public Car(String brand, String color, double price) {
        this.brand = brand;
        this.color = color;
        this.price = price;
    }
}
```



## 封装
将对象的内部（数据）和行为（方法）包装到在一起，并对外隐藏实现细节，成员变量只通过受控的接口（访问器）与外界交互，来提高代码的安全性（合理隐藏、合理暴露）。
访问器：
> -`getter`: 获取属性值 (`getXXX()`)
> - `setter`: 设置属性值（`setXXX(value)`）

封装代码示例：
```java
public class Student {
    // 1. 成员变量私有化
    private String name;
    private int age;

    // 2. 提供公共的 getter/setter
    public String getName() {
        return name;
    }

    public void setName(String name) {
        if (name != null && !name.trim().isEmpty()) {
            this.name = name;
        } else {
            throw new IllegalArgumentException("姓名不能为空");
        }
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        if (age >= 0 && age <= 150) {
            this.age = age;
        } else {
            throw new IllegalArgumentException("年龄必须在 0~150 之间");
        }
    }
}

// 使用
Student s = new Student();
s.setAge(20);   //  合法
s.setAge(-5);   //  抛出异常，防止非法数据


```